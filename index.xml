<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dan Octavian</title>
    <link>https://danoctavian.github.io/</link>
    <description>Recent content on Dan Octavian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Mar 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://danoctavian.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Thinking in coroutines in Node.js</title>
      <link>https://danoctavian.github.io/2019/03/25/thinking-coroutines-nodejs/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://danoctavian.github.io/2019/03/25/thinking-coroutines-nodejs/</guid>
      <description>Thinking in coroutines in Node.js  Yeah, I think it’s… for a particular class of application, which is like, if you’re building a server, I can’t imagine using anything other than Go. That said, I think Node’s non-blocking paradigm worked out well for JavaScript, where you don’t have threads. And I think that a lot of the problems with kind of the call-back soup problem, where you have to jump into many anonymous functions to complete what you’re doing has been alleviated these days, with the async keyword, the async feature that’s in Javascript now.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://danoctavian.github.io/top/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://danoctavian.github.io/top/about/</guid>
      <description> About me Enjoy building things.
 Nothing strengthens authority so much as silence. - Leonardo da Vinci
 </description>
    </item>
    
  </channel>
</rss>